## Compare Mini-Grid Site Locations to Current Energy Access Maps

```{r}
library(tidyverse)
library(sf)
```

```{r}
# Load the mini-grid site locations from each developer

# cbil
cbil <- st_read("data/cbil/cbil_sites.geojson")
pg <- st_read("data/pg/pg_sites.geojson")
cluber <- st_read("data/cluber/cluber_sites.geojson")

# add source column to each
cbil <- cbil %>% mutate(source = "cbil", site_name = site)
pg <- pg %>% mutate(source = "pg")
cluber <- cluber %>% mutate(source = "cluber")

# clean up cbil df
cbil <- cbil %>% mutate(date_commissioned = as.Date(metadataprojectcod, format = "%Y-%m-%d"))
cbil <- cbil %>% select(site_name, country, date_commissioned, source, geometry)
glimpse(cbil)

# clean up pg df
glimpse(pg)
pg <- pg %>% select(site_name, country, date_commissioned, source, geometry)

# clean up cluber df
glimpse(cluber)
cluber <- cluber %>% select(site_name, country, date_commissioned, source, geometry)

# combine
mgs <- bind_rows(cbil, pg, cluber)
rm(cbil, pg, cluber)

# export
st_write(mgs, "data/mgs/mgs.geojson")
```

## Filter Mini-Grid Sites by Country
```{r}
# read in mgs
mgs <- st_read("data/mgs/mgs.geojson")
# countries of interest
iea <- c("Ghana", "Senegal", "Uganda")

# show unique list of countries from mgs
unique(mgs$country)

# [1] "Kenya"        "Sierra Leone" "DR Congo"     "Nigeria"      "Tanzania"    
#  [6] "Haiti"        "Zambia"       NA             "Ghana"        "Mozambique"  
# [11] "Benin"        "Angola"       "Burkina Faso" "Cameroon"     "Ethiopia"    
# [16] "Liberia"      "Madagascar"   "Mali"         "Mauritania"   "Senegal"     
# [21] "Togo"         "Uganda"       "Zimbabwe"    

# filter mgs by countries of interest
mgs <- mgs %>% filter(country %in% iea)
rm(iea)
# keeps 117 sites
# count number of mgs per developer
mgs %>% count(source)
# 4 from cbil, 113 from cluber
# count number per country
mgs %>% count(country)
# 6 for Ghana, 109 for Senegal, 2 for Uganda

# remove any two sites that are in the same location
mgs <- mgs %>% distinct(site_name, .keep_all = TRUE)
# remove any two sites that have identical geometry
mgs <- mgs %>% distinct(geometry, .keep_all = TRUE)

# map where remaining sites are
ggplot(mgs) +
  geom_sf(aes(color = country)) +
  theme_minimal()

# export 
st_write(mgs, "data/oemap/mgs_iea_114.geojson")
```

## Import OE Map GeoJSON Data
```{r}
grid_cells <- st_read("data/oemap/grid_cells.geojson")
mgs <- st_read("data/oemap/mgs_iea_114.geojson")

# visualize the gridcells
ggplot(grid_cells) +
  geom_sf() +
  theme_minimal()

# Clean geometries
grid_cells <- st_make_valid(grid_cells)
mgs <- st_make_valid(mgs)

# filter the grid cells for just the ones that contain a mini-grid site within them
grid_cells_mgs <- st_join(grid_cells, mgs, join = st_contains)

# filter just the ones that have a mini-grid site within them
grid_cells_mgs <- grid_cells_mgs %>% filter(!is.na(site_name))

# export
st_write(grid_cells_mgs, "data/oemap/grid_cells_mgs.geojson")
```

## Clean Up the OE Map Download Links
```{r}
# read in grid cells with mini-grid sites
download_links <- read_csv("data/oemap/download_links.csv")

# format for link
# Working: https://biospheric-vector.s3.amazonaws.com/open-energy-maps/2024Q1-downloads-2/20240326-2/SEN/435853_geoms.zip
# Broken: https://biospheric-vector.s3.amazonaws.com/open-energy-maps/2024Q1-downloads/20240326/GHA/471928_geoms.geojson

# replace .geojson with .zip at the end of each cell in the column download_link
download_links$download_link <- gsub(".geojson", ".zip", download_links$download_link)

# replace 2024Q1-downloads with 2024Q1-downloads-2 in the download_link column
download_links$download_link <- gsub("2024Q1-downloads", "2024Q1-downloads-2", download_links$download_link)

# replace /20240326/ with /20240326-2/ in the download_link column
download_links$download_link <- gsub("/20240326/", "/20240326-2/", download_links$download_link)

# reexport the download_links
write_csv(download_links, "data/oemap/download_links_fix.csv")
```

## Download the Building Level Data
```{r}
# read in the mg grid cells
grid_cells_mgs <- st_read("data/oemap/grid_cells_mgs.geojson")
# read in the download links
download_links <- read_csv("data/oemap/download_links_fix.csv")

# filter download links for just the grid cells with mini-grid sites
download_links <- download_links %>% filter(grid_cell_id %in% grid_cells_mgs$grid_cell_id)

# loop over the download links and download the data
for (i in 1:nrow(download_links)) {
  download.file(download_links$download_link[i], paste0("data/oemap/grid_cells_zip/", download_links$grid_cell_id[i], ".zip"))
}

# print the first row second column of download_links, don't cut it off
print(download_links$download_link[1], width = 1000)
```

## Unzip the Building Level Data
```{r}
# unzip all the files
files <- list.files("data/oemap/grid_cells_zip", full.names = TRUE)
lapply(files, unzip, exdir = "data/oemap/grid_cells_geojson")

# manually delete the license file
```

## Read in and Combine the OE GeoJSON files
```{r}
# read in the geojson files from oe into a single sf
files <- list.files("data/oemap/grid_cells_geojson", full.names = TRUE)

# read in the first file
# oedata <- st_read(files[1])

# loop over the rest of the files and bind them to the first file
# for (i in 2:length(files)) {
#   oedata <- bind_rows(oedata, st_read(files[i]))
# }

# redo this with lapply
oedata_list <- lapply(files, st_read)
oedata2 <- do.call(rbind, oedata_list)

rm(files)
# set crs to 4326
st_crs(oedata) <- 4326

# export as a single geojson
st_write(oedata, "data/oemap/oedata.geojson")
```

## Do Mini-Grid Analysis
```{r}
# library(terra)

# # read in the mini-grid data
# mgs <- vect("data/oemap/mgs_iea_114.geojson")
# oe <- vect("data/oemap/oedata.geojson")

# # count the number of features in oe that lie within each feature of mgs
# oe_mgs <- vect(oe, mgs, count = TRUE)

```

## Export the Mini-Grid Sites with a 1km Buffer
```{r}
# read in the grid cells mgs
mgs <- st_read("data/oemap/mgs_iea_114.geojson")
mgs_grid_cells <- st_read("data/oemap/grid_cells_mgs.geojson")
# convert mgs_grid_cells to df
mgs_grid_cells <- st_drop_geometry(mgs_grid_cells)
mgs_grid_cells <- mgs_grid_cells %>% select(site_name, grid_cell_id)

# for each mini-grid in mgs pull in the grid_cell_id from mgs_grid_cells matching by site_name
mgs <- mgs %>% left_join(mgs_grid_cells, by = "site_name")
rm(mgs_grid_cells)
# clean the geometries
mgs <- st_make_valid(mgs)

# convert geometry from a point to 1km buffer
# this is in geographic coordinates, so it's using arc seconds
print(mgs$geometry[1])
mgs <- mgs %>% st_buffer(1000)
print(mgs$geometry[1])

# export the mini-grid sites with the buffer
st_write(mgs, "data/oemap/mgs_buffer_1km.geojson")
```

## Get Background Map and Visualize a Mini-Grid Site
```{r}
library(ggmap) # for getting map backgrounds
library(dotenv) # for environment variables

mgs <- st_read("data/oemap/mgs_buffer_1km.geojson")
# get bbox of inter
bbox <- st_bbox(mgs[1,])
print(bbox)
# structure(c(xmin = -2.1301409793829, ymin = 7.72019593581591, 
# xmax = -2.09349023557637, ymax = 7.75017246739207), class = "bbox", crs = structure(list(
#    input = "WGS 84", wkt = "GEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]"), class = "crs"))
# convert bbox to this format 
# bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),

# set the bbox
left <- as.numeric(bbox["xmin"])
bottom <- as.numeric(bbox["ymin"])
right <- as.numeric(bbox["xmax"])
top <- as.numeric(bbox["ymax"])

center <- c(
  lon = (left + right) / 2,
  lat = (bottom + top) / 2
)

# read in env file
load_dot_env(".env")
stadia.maps.api.key <- Sys.getenv("STADIA_MAPS_API_KEY")
google.maps.api.key <- Sys.getenv("GOOGLE_MAPS_API_KEY")

# configure ggmap with api keys
register_google(google.maps.api.key)
register_stadiamaps(stadia.maps.api.key)

# get background map
map <- ggmap::get_googlemap(
  center = center, 
  zoom = 14, 
  maptype = "satellite"
)

# display map
ggmap(map) + 
  geom_sf(data = mgs[1,], fill = NA, color = "green", size = 3, inherit.aes = FALSE)

# export map as RDS
saveRDS(map, "data/oemap/map.rds")
```

## Analyze a Single Mini-Grid Site
```{r}
# read back in mg
mgs <- st_read("data/oemap/mgs_buffer_1km.geojson")

# for the first minigrid site, pull out the grid cell id
grid_cell_id <- mgs$grid_cell_id[1]
sample_mg <- mgs[1, ]

# create fileanme in format data/oemap/grid_cells_geojson/425749_geoms.geojson
filename <- paste0("data/oemap/grid_cells_geojson/", grid_cell_id, "_geoms.geojson")

# read in the file
grid_cell <- st_read(filename)

# clean the geometries
# grid_cell <- st_make_valid(grid_cell)

# grab just the features from grid_cell that intersect with the first mini-grid site
inter <- st_intersection(grid_cell, sample_mg)
inter$geometry[1]


# calculate the mean of elec.access....
mean(inter$elec.access....)
nrow(inter)
sd(inter$elec.access....)

# find the centroid of sample_mg as it's own sf
sample_mg_pt <- st_centroid(sample_mg)

# set crs of sample_mg to 4326
st_crs(sample_mg) <- 4326
# set crs of inter to 4326
st_crs(inter) <- 4326
# caculate the distance from the village center to each building center
inter$distance <- st_distance(inter, sample_mg_pt)

# export inter as RDS
saveRDS(inter, "data/oemap/inter.rds")
```

## Plot the Results
```{r}
library(units)
library(ggmap)

# import data and map
inter <- readRDS("data/oemap/inter.rds")
map <- readRDS("data/oemap/map.rds")


# create a density plot of inter$elec.access....
ggplot(inter) +
  geom_density(aes(x = elec.access....), fill = "darkgreen", alpha = 0.5) +
  ggtitle("Density Plot of Electricity Access Probability by Building at a Mini-Grid Site") +
  labs(x = "Electricity Access Probability (%)", y = "Density") +
  theme_bw() +
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")

# plot access probability by building with distance from village center
ggplot(inter) +
  geom_point(aes(x = distance, y = elec.access....)) +
  geom_smooth(aes(x = distance, y = elec.access....), method = "gam", se = TRUE) +
  ggtitle("Electricity Access Probability by Building at a Mini-Grid Site") +
  labs(x = "Distance from Village Center (m)", y = "Electricity Access Probability (%)") +
  theme_bw() +
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")


# color by elec.access.... with virdis color scale
inter <- inter %>%
  rename(prob_elec_access = elec.access....)
  
ggmap(map) +
  geom_sf(data = inter, aes(fill = prob_elec_access), inherit.aes = FALSE) +
  geom_sf(data = sample_mg, fill = NA, color="blue", inherit.aes = FALSE) +
  geom_sf(data = sample_mg_pt, color = "blue", size = 5, inherit.aes = FALSE) +
  scale_fill_viridis_c() +
  ggtitle("Electricity Access Probability by Building at a Mini-Grid Site") +
  theme_bw() + 
  # theme(text = element_text(size = 28, family = "serif")) +
  # move legend to the bottom
  theme(legend.position = "bottom") 
  # remove long and lat axis labels
  # theme(axis.text.x = element_blank(), axis.text.y = element_blank()) +
  # add a scale bar
  # scalebar(x.min = left, x.max = right, y.min = bottom, y.max = top, dist = 1000, dist_unit = "m", st.dist = 0.1, st.dist_unit = "km")

# redo this plot using a Stadia maps background map from ggmap
# get the bounding box of the intersection
bbox <- st_bbox(inter)
bbox <- c(left = bbox["xmin"], bottom = bbox["ymin"], right = bbox["xmax"], top = bbox["ymax"])
# get the stadia map
stadia <- get_stadiamap(bbox, zoom = 12, maptype = "stamen_toner_lite")

# # plot grid_cell with geom_sf
# ggplot(grid_cell) +
#   geom_sf() +
#   theme_minimal()
```

## Loop Over All Mini-Grid Sites
```{r}
# read in the mini-grid sites
mgs <- st_read("data/oemap/mgs_buffer_1km.geojson")
# filter out nas
mgs <- mgs %>% filter(!is.na(grid_cell_id))

# convert to list for lapply
mgs_list <- lapply(1:nrow(mgs), function(i) mgs[i, , drop = FALSE])

# Define the function
process_minigrid_site <- function(mg_feature) {
    print(paste0("Now processing: ", mg_feature$site_name))
    # Extract grid_cell_id from the current mini-grid site feature
    grid_cell_id <- mg_feature$grid_cell_id
    
    # Create filename in the specified format
    filename <- paste0("data/oemap/grid_cells_geojson/", grid_cell_id, "_geoms.geojson")
    
    # Read in the corresponding grid cell file
    grid_cell <- st_read(filename)
    
    # Clean the geometries
    grid_cell <- st_make_valid(grid_cell)
    
    # Grab just the features from grid_cell that intersect with the current mini-grid site
    inter <- st_intersection(grid_cell, mg_feature)
    
    # Calculate the mean, count, and standard deviation of elec.access
    # Replace 'elec.access' with the correct column name if different
    mean_elec_access <- mean(inter$elec.access...., na.rm = TRUE)
    count_elec_access <- nrow(inter)
    sd_elec_access <- sd(inter$elec.access...., na.rm = TRUE)
    
    # Return a list containing the results
    return(list(mean = mean_elec_access, count = count_elec_access, sd = sd_elec_access))
}

# Example usage with lapply (assuming 'mgs' is already read and available)
# Note: mgs should be a list of sf features. If mgs is an sf object, convert it to a list of features.
# This can be done using something like `lapply(1:nrow(mgs), function(i) mgs[i,])`
results <- lapply(mgs_list, process_minigrid_site)

# convert results to a data frame
results <- do.call(rbind, results)

# add results to mgs
mgs <- cbind(mgs, results)

# convert mean, count, and sd to numeric from list columns
mgs$mean <- as.numeric(mgs$mean)
mgs$count <- as.numeric(mgs$count)
mgs$sd <- as.numeric(mgs$sd)

glimpse(mgs)
# save mgs
st_write(mgs, "data/oemap/mgs_buffer_results.geojson")
```

## Look at the results
```{r}
mgs <- st_read("data/oemap/mgs_buffer_results.geojson")
# filter out the NAs
mgs <- mgs %>% filter(!is.na(mean))

# plot the distribution of mean elec.access with density, fill by country
density_by_country <- ggplot(mgs) +
  geom_density(aes(x = mean, fill = country), alpha = 0.5, ) +
  ggtitle("Density Plot of Mean Electricity Access Probability by Mini-Grid Site") +
  labs(x = "Mean Electricity Access Probability of Mini-Grid Sites (%)", y = "Density") +
  theme_bw() +
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")
density_by_country
ggsave("figures/oemap/density_by_country.png", density_by_country, width = 16, height = 8, units = "in", dpi = 300)

# density plot of mean, fill with darkgreen
density_overall <- ggplot(mgs) +
  geom_density(aes(x = mean), fill = "darkgreen", alpha = 0.5) +
  ggtitle("Density Plot of Mean Electricity Access Probability by Mini-Grid Site") +
  labs(x = "Mean Electricity Access Probability of Mini-Grid Sites (%)", y = "Density") +
  theme_bw() +
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")
density_overall
ggsave("figures/oemap/density_overall.png", density_overall, width = 16, height = 8, units = "in", dpi = 300)

# create a summary table of the mean, count, and sd by coutnry
mgs_df <- st_drop_geometry(mgs)
mgs_summary <- mgs_df %>% 
  group_by(country) %>% 
  summarise(
    building_count = sum(count), 
    avg_num_buildings = mean(count),
    n_grids = n(),
    mean_access_prob = mean(mean), 
    sd_access_prob = mean(sd, na.rm = TRUE),
    earliest_grid = min(date_commissioned),
    latest_grid = max(date_commissioned)
  )
  # print entire df, don't let it get truncated
print(mgs_summary, width = Inf)

```

## Other Charts Not Used in Paper
```{r}

# plot box and whisker plot of mean
ggplot(mgs) +
  geom_boxplot(aes(y = mean)) +
  ggtitle("Boxplot of Mean Electricity Access Probability by Mini-Grid Site") +
  theme_bw()

# plot date_commissioned on the x versus mean on the y
ggplot(mgs) +
  geom_point(aes(x = date_commissioned, y = mean)) +
  ggtitle("Electricity Access Probability by Mini-Grid Site Commission Date") +
  theme_bw() + 
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")

# plot histogram of mean
ggplot(mgs) +
  geom_histogram(aes(x = mean), binwidth = 5) +
  ggtitle("Histogram of Mean Electricity Access Probability by Mini-Grid Site") +
  theme_bw() +
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")


# plot histogram of commissioning dates
ggplot(mgs) +
  geom_histogram(aes(x = date_commissioned), binwidth = 365) +
  ggtitle("Histogram of Mini-Grid Site Commission Dates") +
  theme_bw() +
  theme(text = element_text(size = 24, family = "serif"), legend.position = "bottom")


# macro stats
summary(mgs$mean)
nrow(mgs)

# count the number of sites with < 50% mean
mgs %>% filter(mean < 50) %>% count()
```